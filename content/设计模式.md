## 设计模式

```Bash
创建型设计模式：单例、原型、工厂方法、抽象工厂、建造者等5种。
结构型设计模式：代理、适配器、桥接、装饰、享元、组合、外观等7种。
行为型设计模式：模板方法、策略命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器、命令等11种。

简单工厂类：
抽象产品(纯虚函数)+n个具体产品（重载纯虚+抽象指针指针具体产品）+具体工厂（根据产品类型创建类）
#include <iostream>
#include <string>
class BMW
{
public:
    virtual void GetCar() = 0;
};

class BMW320 : public BMW
{
public:
    BMW320(){};
    void GetCar()
    {
        std::cout << "BMW320" << std::endl;
    }
};

class BMW520 : public BMW
{
public:
    BMW520(){};
    void GetCar()
    {
        std::cout << "BMW520" << std::endl;
    }
};

//工厂类
class SimpleFactory
{
public:
    SimpleFactory(){};
    BMW* CreateCar(std::string name)
    {
        if (name == "BMW320")
        {
            return new BMW320();
        }
        else if (name == "BMW520")
        {
            return new BMW520();
        }
        else
        {
            return NULL;
        }
    }
};
int main(int argc, char const* argv[])
{
    SimpleFactory sf;
    BMW*          car1 = sf.CreateCar("BMW320");
    BMW*          car2 = sf.CreateCar("BMW520");
    car1->GetCar();
    car2->GetCar();
    return 0;
}

工厂类：抽象产品(纯虚函数)+n个具体产品（重载纯虚+抽象指针指针具体产品）+抽象工厂(纯虚函数)+n个具体工厂（重载纯虚+抽象指针指针具体工厂）
#include <iostream>
#include <string>
class BMW
{
public:
    virtual void GetCar() = 0;
};

class BMW320 : public BMW
{
public:
    BMW320(){};
    void GetCar()
    {
        std::cout << "BMW320" << std::endl;
    }
};

class BMW520 : public BMW
{
public:
    BMW520(){};
    void GetCar()
    {
        std::cout << "BMW520" << std::endl;
    }
};

//抽象工厂类
class Factory
{
public:
    virtual BMW* CreateCar(std::string name) = 0;
};
//具体工厂1
class BMW320Factory : public Factory
{
public:
    BMW320Factory(){};
    BMW* CreateCar(std::string name)
    {
        return new BMW320();
    }
};
//具体工厂2
class BMW520Factory : public Factory
{
public:
    BMW520Factory(){};
    BMW* CreateCar(std::string name)
    {
        return new BMW520();
    }
};
int main(int argc, char const* argv[])
{
    Factory* sf1 = new BMW320Factory();
    Factory* sf2 = new BMW520Factory();

    BMW* car1 = sf1->CreateCar("BMW320");
    BMW* car2 = sf2->CreateCar("BMW520");
    car1->GetCar();
    car2->GetCar();
    return 0;
}

构造者类型：
产品（Product）：表示要构建的复杂对象，包含多个组成部件。
抽象建造者（Abstract Builder）：定义创建产品各个部件的接口，并声明一个方法返回最终的完整产品。
具体建造者（Concrete Builders）：实现抽象建造者的接口，提供创建产品各个部件的详细实现，并在最后返回一个完整的具体产品实例。
导演者（Director）：负责调用具体建造者的相关方法来一步步构建产品，它不涉及具体产品的部件创建细节，只负责按特定顺序安排建造过程

direcotr(具体build的ptr+组织构造产品过程)-》抽象build(定义构造步骤，但是不包含构造顺序)/具体build(具体实现+产品ptr)->抽象产品(产品需要的内容接口)/具体build(内容接口的实现)

#include <iostream>
#include <memory>
#include <string>
//抽象产品类
class Computer
{
public:
    using ptr = std::shared_ptr<Computer>;
    Computer() {}
    void setBoard(const std::string& board)
    {
        _board = board;
    }
    void setDisplay(const std::string& display)
    {
        _display = display;
    }
    virtual void setOs() = 0;
    std::string  toString()
    {
        std::string computer = "Computer:{\n";
        computer += "\tboard=" + _board + ",\n";
        computer += "\tdisplay=" + _display + ",\n";
        computer += "\tOs=" + _os + ",\n";
        computer += "}\n";
        return computer;
    }

protected:
    std::string _board;
    std::string _display;
    std::string _os;
};
//具体产品类
class MacBook : public Computer
{
public:
    using ptr = std::shared_ptr<MacBook>;
    MacBook() {}
    virtual void setOs()
    {
        _os = "Max OS x12";
    }
};
//抽象构建者
class Builder
{
public:
    using ptr                                                      = std::shared_ptr<Builder>;
    virtual void          buildBoard(const std::string& board)     = 0;
    virtual void          buildDisplay(const std::string& display) = 0;
    virtual void          buildOs()                                = 0;
    virtual Computer::ptr build()                                  = 0;    //创建实例返回的指针的虚函数
};
//具体产品构造者
class MacBookBuilder : public Builder
{
public:
    using ptr = std::shared_ptr<MacBookBuilder>;
    MacBookBuilder() : _computer(new MacBook()) {}
    virtual void buildBoard(const std::string& board)
    {
        _computer->setBoard(board);
    }
    virtual void buildDisplay(const std::string& display)
    {
        _computer->setDisplay(display);
    }
    virtual void buildOs()
    {
        _computer->setOs();
    }
    virtual Computer::ptr build()
    {
        return _computer;
    }

private:
    Computer::ptr _computer;
};
//提供给调用者
class Director
{
public:
    Director(Builder* builder) : _builder(builder){};
    void construct(const std::string& board, const std::string& display)
    {
        _builder->buildBoard(board);
        _builder->buildDisplay(display);
        _builder->buildOs();
    }

private:
    Builder::ptr _builder;
};

代理模式：
当客户端对象需要访问远程主机中的对象时可以使用远程代理。
当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。
当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。
当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。
当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代
使用：
//抽象主题
public interface Landlord {
    void rentHome();
}
//实际主题
public class Coder implements Landlord {
    @Override
    public void rentHome() {
        System.out.println("租个70平房子");
    }
}
//代理
public class Ziru implements Landlord {
    @Override
    public void rentHome() {
        Coder coder=new Coder();
        coder.rentHome();
    }
}

装饰器模式：
#include <iostream>
//抽象类
class Hero
{
public:
    virtual void show_skill() = 0;
};
//具体类:基本功能
class runHero : public Hero
{
    void run_skill()
    {
        std::cout << "只能跑的超人" << std::endl;
    }
    virtual void show_skill()
    {
        run_skill();
    }
};
class flyHero : public Hero
{
private:
    Hero* m_hero;
public:
    flyHero(Hero* hero)
    {
        this->m_hero = hero;
    }
    void fly_skill()
    {
        std::cout << "拥有飞行技能" << std::endl;
    }
    virtual void show_skill()
    {
        this->m_hero->show_skill();
        fly_skill();
    }
};

class laserHero : public Hero
{
private:
    Hero* m_hero;

public:
    laserHero(Hero* hero)
    {
        this->m_hero = hero;
    }
    void laser_skill()
    {
        std::cout << "拥有激光眼技能" << std::endl;
    }
    virtual void show_skill()
    {
        this->m_hero->show_skill();
        laser_skill();
    }
};
int main(int argc, char const* argv[])
{
    Hero* myHero1 = NULL;
    std::cout << "第一个英雄" << std::endl;
    std::cout << "初始形态" << std::endl;
    myHero1 = new runHero();
    myHero1->show_skill();
    std::cout << "第一次升级" << std::endl;
    Hero* myHero2 = new flyHero(myHero1);
    myHero2->show_skill();
    std::cout << "第二次升级" << std::endl;
    Hero* myHero3 = new laserHero(myHero2);
    myHero3->show_skill();
    return 0;
}

适配器模式：
#include <iostream>
#include <memory>
//客户需要的TTL接口
class TTL
{
public:
    virtual void get_ttl() = 0;
};
//Adaptee只有rs232接口
class RS232
{
public:
    void get_rs232()
    {
        std::cout << "RS232接口" << std::endl;
    }
};
//Adapter适配器
class adapter : public TTL
{
private:
    RS232* m_232;
public:
    adapter(RS232* m_232)
    {
        this->m_232 = m_232;
    }
    void adapter232_to_ttl()
    {
        std::cout << "适配器：将RS232转换为TTL" << std::endl;
    }
    virtual void get_ttl()
    {
        this->m_232->get_rs232();
        adapter232_to_ttl();
        std::cout << "ttl接口" << std::endl;
    }
};
int main(int argc, char const* argv[])
{
    std::shared_ptr<RS232> my232 = nullptr;
    my232                        = std::make_shared<RS232>();

    std::shared_ptr<adapter> ad = nullptr;
    ad                          = std::make_shared<adapter>();
    my232->get_rs232();
    std::cout << "========" << std::endl;
    ad->get_ttl();
    return 0;
}

模板方法模式：
父类：定义步骤和确定的事情，子类具体实现
```