权限系统

```Shell
proc目录
/proc 目录是一个特殊的虚拟文件系统，在 Linux 系统中起着关键作用。以下是对 /proc 目录的详细解释：
文件系统类型：/proc 目录是一个虚拟文件系统（procfs），不占用磁盘空间，而是由内核动态生成和维护的一个目录结构。它提供了一个简单的接口来访问系统内核数据结构，以及当前正在运行的进程信息。在 Linux 下，将这样的虚拟文件系统称为 proc 文件系统。
进程信息：在 /proc 目录下，每个运行的进程都有一个以数字命名的目录，代表该进程的 PID（进程号）。例如，/proc/1234 就代表 PID 为 1234 的进程。在这个目录下包含了关于该进程的许多信息，如命令行参数、环境变量、进程状态、打开的文件描述符等。
系统信息：/proc 目录中还包含了一些系统级信息，如 /proc/version 包含了内核版本信息，/proc/cpuinfo 包含了 CPU 相关信息，/proc/meminfo 包含了内存相关信息等。
控制接口：/proc 目录也提供了一些控制和配置接口，例如可以通过修改某些文件中的内容来改变系统的一些行为或设置，如通过 /proc/sys 目录下的文件可以进行内核参数的配置。
性能监控：/proc 目录也用于系统性能监控和调试，可以查看系统负载、内存使用情况、CPU 使用率等信息，从而帮助诊断系统问题。
总之，/proc 目录在 Linux 系统中扮演着非常重要的角色，提供了访问系统信息、进程信息以及调试和性能监控的接口。通过读取和操作 /proc 目录下的文件可以获取到系统运行时的各种信息，帮助用户更好地了解和管理系统。

在编译后的程序位置执行脚本
char exePath[PATH_MAX];
        realpath("/proc/self/exe", exePath);
        char*       dir           = dirname(exePath);
        std::string executableDir = dir;
        std::string command       = "bash " + executableDir + "/config/ldm/check_log_size.sh";
        // 使用 system() 函数执行Shell脚本
        int result = system(command.c_str());
        if (result != 0)
        {
            MCOUT(LOG::ERROR, logCtx) << "Error executing shell script." << std::endl;
        }
```

```C++
执行权限是用来访问目录内容的权限。如果目录没有执行权限，即使有写权限也无法在其中创建新目录。
目录权限：要在目录中创建文件，该目录必须具有写权限。如果没有写权限，则无法在其中创建新文件。
文件权限：创建的新文件将继承其所在目录的权限。通常情况下，用户可以在自己的目录下创建文件，并对这些文件进行读写操作，因为目录的拥有者对其目录拥有完全控制权。对于群组和其他用户来说，他们必须有执行该目录的权限才能创建文件。

root用户拥有最高权限，可以使用 chmod 命令来更改文件和目录的权限，以获得对它们的访问或操作权限。
通过 chmod 命令，root用户可以修改文件或目录的权限属性，包括读（r）、写（w）和执行（x）权限，以及文件所有者、所属组和其他用户的权限。这样，root用户可以解除文件和目录的权限限制，或者为其他用户开放对它们的访问权限

目录及文件权限：在Linux系统中，每个文件和目录都有权限属性，
包括该文件或目录的所有者、所属组以及其他用户的读、写、执行权限等。root  用户可以访问系统上的所有文件和目录，并且可以修改任何文件或目录的权限，这使得root用户可以对整个文件系统进行管理和操作。

drwxrwxr-x 2 cjl cjl 4096 4月  24 20:28 ldm
根据您提供的信息，这是一个关于一个名为 "ldm" 的文件夹的权限的输出。以下是解释每个部分的含义：
第一列 "drwxrwxr-x"：表示该文件夹的权限。第一个字符 'd' 表示这是一个文件夹（目录），接着的三组字符 "rwx"  分别代表所有者（Owner）权限、群组（Group）权限和其他用户（Others）权限。其中 'r' 代表读权限，'w' 代表写权限，'x'  代表执行权限。因此 "drwxrwxr-x" 表示文件夹所有者有读、写、执行权限，群组用户有读、写、执行权限，其他用户有读、执行权限。
第二列 "2"：表示该文件夹中包含的子文件夹或文件数目。
第三列 "cjl"：表示该文件夹的所有者。
第四列 "cjl"：表示该文件夹的所属组。
第五列 "4096"：表示该文件夹的大小（以字节为单位）。
第六列 "4月 24 20:28"：表示该文件夹的最后修改时间，格式为 月 日 时间。

/etc/passwd是权限文件
/etc/shadow是密码
chmod和chown(change mod和change owner)
chmod用于：改变权限,-R参数（Recursive递归的）
chown用于改变文件/目录的所有者

id 用户名:查看信息
用户权限检查顺序是：拥有者->所属组->其他用户

文件权限：rwx：r只包括读，w只包括写入，x包括./
cp,rm之类的和文件权限相关
目录权限：rwx:r是指ls但是ls -l不可以,w也不能cd，x可以cd;
eg:r_x可以保证进入并查看文件中的文件，但是对已经存在的文件进行操作要查看具体文件，但是无法创建新文件
w：有了w权限才可以，相当于对目录增加新的内容;rw_:无法在目录下创建

文件权限常用：644;目录权限默认755


root 是系统中的最高权限用户，通常可以绕过一般用户的权限限制执行系统操作。因此，root 用户拥有对系统中任何文件和目录的完全访问权限，无论文件的权限设置如何
即权限系统是面向普通用户的
```

## 进程调度SCHED

```C
SCHED_OTHER:默认分时调度
SCHED_FIFO:实时调度,适用于运行时间比较短的进程；因为他是长作业优先的，避免死锁，无时间片
SCHED_RR:实时调度,适用于运行时间比较长的进程
```

## 内存管理MMU

```C
每创立一个进程，为其分配虚拟的内存空间，包括用户区和内核区；
用户区：
1.堆区（用户自己申请的内存），
2.栈区（局部变量），
3.全局区/静态（static和全局变量），
    静态成员：// 静态成员(只有一个,所有对象共享一个,在编译阶段就分配内存,属于类)
    1.静态成员变量(类内声明,类外初始化,必须的) 2.静态成员函数
    static是调用的时候进行初始化，然后一直放在全局区，跟随整个程序的结束而结束
        在C++中，静态修饰的函数（使用static关键字修饰的函数）不会随着主函数的释放而释放。
        静态函数在程序启动时就被加载到内存中，并且一直保留在内存中直到程序结束。
        静态函数与普通函数的区别在于其作用域。静态函数仅在声明它的源文件内可见，无法被其他源文件访问。
        因此，静态函数的生命周期是与整个程序的生命周期相同的。
        即使主函数（main函数）执行完毕并返回，静态函数依然存在于内存中，可以在其他函数中调用或者通过指针调用。
        当整个程序结束时，所有静态函数都会被释放。
4.常量区（常量字符串，const）
```

## 虚拟文件系统VFS

```C
让数据有效存储到物理硬盘上，Linux常见的由ext2和ext3

linux默认打开了三个文件描述符
0是标准输出，1是标准输出，2是标准错误
分配规则，找到最小的未被分配的文件描述符

## Linux结构目录

```C
bin:可执行二进制文件(绿色)
sbin:给root用的二进制文件
dev:设备文件:可以与硬件/驱动程序交互
home:普通用户的家目录:~  一个用户一个目录
root:root用户的家目录
lib:系统运行过程中需要加载的静态库/动态库
mnt或media:挂载外设，mnt临时挂载，media是长时间挂载
usr:unix system resource 系统资源文件：~
子文件：games:游戏
        local:自己编译的所有二进制文件
 boot:开机启动项 services对应的是端口号
 etc:配置文件,passwd存储的是权限，shadow是密码
opt:第三方软件目录，同usr/local
var:经常变化的软件，像日志文件;随着系统运行而改变的缓存文件
tmp:每次重启清空，可用于存储运行的程序生成的文件
lost+found:做系统恢复
boot:启动系统所需要的文件

/proc存放运行时的目录：动态创建的，本身并不存在
720   836  cgroups     ioports        mounts       thread-self
cd 720可以进入该运行程序
进入fd目录

cp 是复制移动
mv 是将原有的移动
查看二进制文件：which
```